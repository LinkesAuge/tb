# TB Scout Application Modernization: Implementation Plan

## File Structure Overview

```
scout/
├── __init__.py
├── main.py (modify)
├── gui.py (modify)
├── overlay.py (modify)
├── window_manager.py (modify)
├── window_interface.py (new)
├── template_matcher.py (modify)
├── text_ocr.py (modify)
├── actions.py (modify)
├── config_manager.py (modify)
├── sound_manager.py (modify)
├── error_handling.py (new)
├── signals.py (new)
├── template_search.py (new)
├── screen_capture/
│   ├── __init__.py (new)
│   ├── capture_manager.py (new)
│   ├── screen_list_model.py (new)
│   ├── window_list_model.py (new)
│   ├── capture_tab.py (new)
│   └── utils.py (new)
├── automation/
│   ├── __init__.py
│   ├── core.py (new)
│   ├── executor.py (modify)
│   ├── gui/ (modify)
│   │   ├── __init__.py
│   │   ├── automation_tab.py (modify)
│   │   └── sequence_builder.py (modify)
│   └── progress_tracker.py (new)
├── utils/
│   ├── __init__.py
│   └── logging_utils.py (new)
├── config/
│   ├── settings.json (modify)
│   └── default_settings.json (new)
└── docs/ (new)
    ├── architecture.md (new)
    ├── components/ (new)
    │   ├── screen_capture.md (new)
    │   ├── overlay.md (new)
    │   └── automation.md (new)
    └── workflows/ (new)
        ├── template_matching.md (new)
        └── automation.md (new)
```

## Detailed Implementation Checklist

### 1. Window Interface and Management Consolidation

- [ ] **Create `window_interface.py`**
  - [ ] Define `WindowInterface` abstract class with methods:
    ```python
    class WindowInterface:
        """Interface for window management operations."""
        def find_window(self) -> bool:
            """Find window by title."""
            raise NotImplementedError
            
        def get_window_position(self) -> Optional[Tuple[int, int, int, int]]:
            """Get window position (x, y, width, height)."""
            raise NotImplementedError
            
        def get_client_rect(self) -> Optional[Tuple[int, int, int, int]]:
            """Get client area rectangle."""
            raise NotImplementedError
            
        def client_to_screen(self, x: int, y: int) -> Tuple[int, int]:
            """Convert client coords to screen coords."""
            raise NotImplementedError
            
        def screen_to_client(self, x: int, y: int) -> Tuple[int, int]:
            """Convert screen coords to client coords."""
            raise NotImplementedError
            
        def capture_screenshot(self) -> Optional[np.ndarray]:
            """Capture screenshot of window."""
            raise NotImplementedError
    ```

- [ ] **Update `window_manager.py`**
  - [ ] Modify `WindowManager` to implement `WindowInterface`
  - [ ] Add `_capture_manager` attribute to store capture manager instance
  - [ ] Implement `_initialize_capture_manager` method to create capture manager
  - [ ] Update `capture_screenshot` to use capture manager if available
  - [ ] Add a legacy capture method for backward compatibility
  - [ ] Add error handling and logging

- [ ] **Modify `window_capture.py`**
  - [ ] Simplify class to focus solely on capture operations
  - [ ] Make it accept a `WindowManager` instance in constructor
  - [ ] Remove duplicate window management code
  - [ ] Use the window manager for all window operations

### 2. Screen Capture Module Implementation

- [ ] **Create `screen_capture/__init__.py`**
  - [ ] Export main classes:
    ```python
    """Screen capture module exports."""
    from .capture_manager import CaptureManager, CaptureInterface
    from .capture_tab import CaptureTab
    from .screen_list_model import ScreenListModel
    from .window_list_model import WindowListModel
    ```

- [ ] **Create `screen_capture/utils.py`**
  - [ ] Implement `qimage_to_numpy` function:
    ```python
    def qimage_to_numpy(qimage):
        """Convert a QImage to a numpy array suitable for OpenCV processing."""
        if qimage is None:
            return None
        
        width = qimage.width()
        height = qimage.height()
        
        if qimage.format() == QImage.Format.Format_RGB32:
            ptr = qimage.constBits()
            arr = np.array(ptr).reshape(height, width, 4)
            return cv2.cvtColor(arr, cv2.COLOR_RGBA2BGR)
        else:
            qimage = qimage.convertToFormat(QImage.Format.Format_RGB32)
            ptr = qimage.constBits()
            arr = np.array(ptr).reshape(height, width, 4)
            return cv2.cvtColor(arr, cv2.COLOR_RGBA2BGR)
    ```
  
  - [ ] Implement `numpy_to_qimage` function:
    ```python
    def numpy_to_qimage(numpy_img):
        """Convert a numpy array (OpenCV image) to QImage."""
        if numpy_img is None:
            return None
        
        rgb_img = cv2.cvtColor(numpy_img, cv2.COLOR_BGR2RGB)
        height, width, channel = rgb_img.shape
        bytesPerLine = channel * width
        return QImage(rgb_img.data, width, height, bytesPerLine, QImage.Format.Format_RGB888)
    ```

- [ ] **Create `screen_capture/capture_manager.py`**
  - [ ] Define `CaptureInterface` class:
    ```python
    class CaptureInterface:
        """Interface defining the contract for any capture implementation."""
        def capture_screenshot(self):
            """Capture and return a screenshot."""
            raise NotImplementedError
    ```
  
  - [ ] Define `SourceType` enum:
    ```python
    class SourceType(Enum):
        """Types of capture sources available."""
        Screen = auto()
        Window = auto()
    ```
  
  - [ ] Implement `CaptureManager` class:
    ```python
    class CaptureManager(QObject, CaptureInterface):
        """Manages screen/window capture using Qt's multimedia capabilities."""
        # Signals
        frame_captured = pyqtSignal(np.ndarray)
        error_occurred = pyqtSignal(str)
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self._source_type = SourceType.Screen
            self._screen_capture = QScreenCapture(self)
            self._window_capture = QWindowCapture(self)
            self._media_capture_session = QMediaCaptureSession(self)
            self._screen_capture.errorOccurred.connect(self._on_screen_capture_error)
            self._window_capture.errorOccurred.connect(self._on_window_capture_error)
            self._media_capture_session.setScreenCapture(self._screen_capture)
            self._media_capture_session.setWindowCapture(self._window_capture)
            self._last_frame = None
            self._capture_timer = QTimer(self)
            self._capture_timer.timeout.connect(self._take_direct_capture)
            self._capture_active = False
            self._screenshots_dir = Path("scout/debug_screenshots")
            os.makedirs(self._screenshots_dir, exist_ok=True)
            # Initialize with primary screen
            self.set_screen(QGuiApplication.primaryScreen())
            self._screen_capture.start()
        
        def set_screen(self, screen):
            # Implementation
            
        def set_window(self, window):
            # Implementation
            
        def start_capture(self, interval_ms=100):
            # Implementation
            
        def stop_capture(self):
            # Implementation
            
        def take_screenshot(self, save_path=None):
            # Implementation
            
        def get_last_frame(self):
            # Implementation
            
        def _update_active(self, active):
            # Implementation
            
        def _take_direct_capture(self):
            # Implementation
            
        def _on_screen_capture_error(self, error, error_string):
            # Implementation
            
        def _on_window_capture_error(self, error, error_string):
            # Implementation
    ```

- [ ] **Create `screen_capture/screen_list_model.py`**
  - [ ] Implement `ScreenListModel` class:
    ```python
    class ScreenListModel(QAbstractListModel):
        """Model that lists all available screens/monitors in the system."""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            app = QApplication.instance()
            app.screenAdded.connect(self.screens_changed)
            app.screenRemoved.connect(self.screens_changed)
            app.primaryScreenChanged.connect(self.screens_changed)
        
        def rowCount(self, index):
            # Implementation
            
        def data(self, index, role):
            # Implementation
            
        def screen(self, index):
            # Implementation
            
        @pyqtSlot()
        def screens_changed(self):
            # Implementation
    ```

- [ ] **Create `screen_capture/window_list_model.py`**
  - [ ] Implement `WindowListModel` class:
    ```python
    class WindowListModel(QAbstractListModel):
        """Model that lists all available capturable windows in the system."""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self._window_list = QWindowCapture.capturableWindows()
        
        def rowCount(self, index):
            # Implementation
            
        def data(self, index, role):
            # Implementation
            
        def window(self, index):
            # Implementation
            
        @pyqtSlot()
        def populate(self):
            # Implementation
    ```

- [ ] **Create `screen_capture/capture_tab.py`**
  - [ ] Implement `CaptureTab` class:
    ```python
    class CaptureTab(QWidget):
        """Tab for selecting and previewing screen/window captures."""
        
        # Signals
        capture_source_changed = pyqtSignal(object)
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self._capture_manager = CaptureManager(self)
            self._capture_manager.error_occurred.connect(self._on_error)
            self._capture_manager.frame_captured.connect(self._on_frame_captured)
            self._create_ui()
            self._capture_manager.start_capture(100)
        
        def _create_ui(self):
            # Implementation with sections for:
            # - Screen selection list
            # - Window selection list
            # - Controls (refresh, capture, etc.)
            # - Preview display
        
        def _on_screen_selection_changed(self, selection):
            # Implementation
            
        def _on_window_selection_changed(self, selection):
            # Implementation
            
        def _on_frame_captured(self, frame):
            # Implementation
            
        def _toggle_auto_capture(self, state):
            # Implementation
            
        def _take_screenshot(self):
            # Implementation
            
        def _on_error(self, error_msg):
            # Implementation
            
        def get_capture_manager(self):
            # Implementation
    ```

### 3. Signal Standardization 

- [ ] **Create `signals.py`**
  - [ ] Define `SignalGroups` for major components:
    ```python
    class OverlaySignals(QObject):
        """Signals related to overlay functionality."""
        match_found = pyqtSignal(object)  # GroupedMatch object
        overlay_toggled = pyqtSignal(bool)  # Is active
        template_matching_toggled = pyqtSignal(bool)  # Is active
        
    class CaptureSignals(QObject):
        """Signals related to screen capture."""
        frame_captured = pyqtSignal(np.ndarray)  # Image as numpy array
        capture_failed = pyqtSignal(str)  # Error message
        screenshot_saved = pyqtSignal(str)  # Path
        
    class AutomationSignals(QObject):
        """Signals related to automation."""
        sequence_started = pyqtSignal(str)  # Sequence name
        sequence_completed = pyqtSignal(str)  # Sequence name
        sequence_error = pyqtSignal(str, str)  # Sequence name, error
        action_started = pyqtSignal(str, int, int)  # Action type, index, total
        action_completed = pyqtSignal(str, int, int)  # Action type, index, total
        
    class OCRSignals(QObject):
        """Signals related to OCR functionality."""
        text_recognized = pyqtSignal(str)  # Recognized text
        coordinates_recognized = pyqtSignal(object)  # GameCoordinates object
    ```

### 4. Error Handling and Logging Improvements

- [ ] **Create `error_handling.py`**
  - [ ] Implement `safe_execute` function:
    ```python
    def safe_execute(func, error_message, default_return=None, *args, **kwargs):
        """Execute function safely with error handling."""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.error(f"{error_message}: {e}", exc_info=True)
            return default_return
    ```
    
  - [ ] Implement `ErrorTracker` class:
    ```python
    class ErrorTracker:
        """Tracks errors for reporting and analysis."""
        
        def __init__(self):
            self.errors = []
            self.max_errors = 100
            
        def add_error(self, module, error_type, message, exception=None):
            """Add an error to the tracker."""
            timestamp = datetime.now().isoformat()
            error_info = {
                'timestamp': timestamp,
                'module': module,
                'type': error_type,
                'message': message,
                'exception': str(exception) if exception else None
            }
            self.errors.append(error_info)
            if len(self.errors) > self.max_errors:
                self.errors.pop(0)
            logger.error(f"Error in {module}: {message}", exc_info=bool(exception))
            
        def get_recent_errors(self, count=10):
            """Get most recent errors."""
            return self.errors[-count:]
            
        def clear_errors(self):
            """Clear error history."""
            self.errors = []
    ```

- [ ] **Create `utils/logging_utils.py`**
  - [ ] Implement context-aware logging functions:
    ```python
    def log_with_context(logger, level, message, context=None):
        """Log message with structured context."""
        if context:
            context_str = " | ".join(f"{k}={v}" for k, v in context.items())
            message = f"{message} | {context_str}"
        logger.log(level, message)
        
    def configure_logging(log_dir=None, file_level=logging.DEBUG, console_level=logging.INFO):
        """Configure logging with file and console handlers."""
        # Implementation to set up logging
    ```

### 5. Template Search Implementation

- [ ] **Create `template_search.py`**
  - [ ] Implement `TemplateSearchExecutor` class:
    ```python
    class TemplateSearchExecutor:
        """Shared implementation of template search functionality."""
        
        def __init__(self, template_matcher, window_manager, overlay=None):
            self.template_matcher = template_matcher
            self.window_manager = window_manager
            self.overlay = overlay
            self.sound_manager = SoundManager()
            
        def execute(self, action):
            """Execute template search with given parameters."""
            search_params = self._prepare_search_params(action)
            return self._perform_search(search_params)
            
        def _prepare_search_params(self, action):
            """Extract and validate search parameters."""
            # Implementation
            
        def _perform_search(self, params):
            """Perform the actual template search."""
            # Implementation
            
        def _handle_matches(self, matches, params):
            """Process and visualize matches."""
            # Implementation
    ```

### 6. Overlay System Refactoring

- [ ] **Update `overlay.py`**
  - [ ] Add `OverlayState` enum:
    ```python
    class OverlayState(Enum):
        """Possible states for the overlay."""
        INACTIVE = auto()
        ACTIVE = auto()
        SEARCHING = auto()
        DRAWING = auto()
    ```
  
  - [ ] Add state machine to `Overlay` class:
    ```python
    def _transition_to_state(self, new_state):
        """Handle state transitions with appropriate actions."""
        if new_state == self.state:
            return False
            
        old_state = self.state
        self.state = new_state
        
        # Handle exit actions for old state
        if old_state == OverlayState.ACTIVE:
            # Exit actions for ACTIVE state
            pass
        # Handle other exit actions
        
        # Handle entry actions for new state
        if new_state == OverlayState.ACTIVE:
            self._show_window()
        elif new_state == OverlayState.INACTIVE:
            self._hide_window()
        # Handle other entry actions
        
        logger.debug(f"Overlay state transition: {old_state} -> {new_state}")
        return True
    ```
  
  - [ ] Refactor `_execute_template_search` by delegating to `TemplateSearchExecutor`:
    ```python
    def _execute_template_search(self, action):
        """Execute template search using shared implementation."""
        search_executor = TemplateSearchExecutor(
            template_matcher=self.template_matcher,
            window_manager=self.window_manager,
            overlay=self
        )
        return search_executor.execute(action)
    ```
  
  - [ ] Create `TransparentOverlay` class using Qt's transparency features:
    ```python
    class TransparentOverlay(QWidget):
        """Qt-based transparent overlay implementation."""
        
        def __init__(self, parent=None):
            super().__init__(parent)
            self.setWindowFlags(
                Qt.WindowType.FramelessWindowHint |
                Qt.WindowType.WindowStaysOnTopHint |
                Qt.WindowType.Tool
            )
            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
            self.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground)
            self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
            
        def paintEvent(self, event):
            """Paint overlay content."""
            painter = QPainter(self)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            # Draw overlay content
    ```

### 7. Configuration System Enhancements

- [ ] **Update `config_manager.py`**
  - [ ] Add environment variable support:
    ```python
    def _get_value(self, section, key, fallback=None, value_type=str):
        """Get configuration value with environment variable override."""
        env_var = f"TBSCOUT_{section.upper()}_{key.upper()}"
        env_value = os.environ.get(env_var)
        
        if env_value is not None:
            # Convert to appropriate type
            if value_type == bool:
                return env_value.lower() in ('true', 'yes', '1', 'on')
            return value_type(env_value)
            
        # Get from config file
        if value_type == bool:
            return self.config.getboolean(section, key, fallback=fallback)
        elif value_type == int:
            return self.config.getint(section, key, fallback=fallback)
        elif value_type == float:
            return self.config.getfloat(section, key, fallback=fallback)
        else:
            return self.config.get(section, key, fallback=fallback)
    ```
  
  - [ ] Add configuration validation:
    ```python
    def validate_configuration(self):
        """Validate configuration settings."""
        errors = []
        
        # Check required sections
        required_sections = ["Overlay", "template_matching", "OCR", "Scanner"]
        for section in required_sections:
            if not self.config.has_section(section):
                errors.append(f"Missing required section: {section}")
        
        # Check specific settings
        if self.config.has_section("OCR"):
            if not self.config.has_option("OCR", "tesseract_path"):
                errors.append("Missing OCR.tesseract_path setting")
            else:
                path = self.config.get("OCR", "tesseract_path")
                if not os.path.exists(path):
                    errors.append(f"Invalid tesseract_path: {path} - file does not exist")
        
        # Check other settings
        # Implementation
        
        return errors
    ```
  
  - [ ] Add a configuration migration system:
    ```python
    def migrate_configuration(self):
        """Migrate configuration from older versions."""
        # Check version
        if not self.config.has_section("Version"):
            self.config.add_section("Version")
            self.config.set("Version", "version", "1.0")
            # Migrate from pre-1.0 format
            
        # Version-specific migrations
        version = self.config.get("Version", "version")
        if version == "1.0":
            # Migrate from 1.0 to 1.1
            # Implementation
            self.config.set("Version", "version", "1.1")
        
        # Save migrated config
        self.save_config()
    ```

### 8. Automation System Improvements

- [ ] **Create `automation/progress_tracker.py`**
  - [ ] Implement `ProgressTracker` class:
    ```python
    class ProgressTracker(QObject):
        """Tracks automation progress with detailed reporting."""
        
        progress_updated = pyqtSignal(int, int, str)  # current, total, description
        action_started = pyqtSignal(str, int)  # action_type, index
        action_completed = pyqtSignal(str, int, bool)  # action_type, index, success
        sequence_completed = pyqtSignal(bool)  # success
        
        def __init__(self):
            super().__init__()
            self.total_actions = 0
            self.current_action = 0
            self.started_at = None
            self.action_durations = {}
            
        def start_sequence(self, action_count):
            """Start tracking a new sequence."""
            self.total_actions = action_count
            self.current_action = 0
            self.started_at = time.time()
            self.action_durations = {}
            
        def start_action(self, action_type, index):
            """Record the start of an action."""
            self.current_action = index
            self.action_durations[index] = {'start': time.time(), 'type': action_type}
            self.action_started.emit(action_type, index)
            self.progress_updated.emit(index, self.total_actions, f"Executing {action_type}")
            
        def complete_action(self, index, success=True):
            """Record the completion of an action."""
            if index in self.action_durations:
                self.action_durations[index]['end'] = time.time()
                self.action_durations[index]['duration'] = (
                    self.action_durations[index]['end'] - self.action_durations[index]['start']
                )
                self.action_durations[index]['success'] = success
            
            self.action_completed.emit(
                self.action_durations.get(index, {}).get('type', 'Unknown'), 
                index,
                success
            )
            
        def complete_sequence(self, success=True):
            """Record the completion of the sequence."""
            duration = time.time() - self.started_at if self.started_at else 0
            self.sequence_completed.emit(success)
            return {
                'total_actions': self.total_actions,
                'completed_actions': self.current_action,
                'duration': duration,
                'success': success,
                'action_durations': self.action_durations
            }
    ```

- [ ] **Create `automation/core.py`**
  - [ ] Implement `AutomationEngine` class:
    ```python
    class AutomationEngine:
        """Core automation logic, independent of UI."""
        
        def __init__(self, window_manager, template_matcher, game_actions):
            self.window_manager = window_manager
            self.template_matcher = template_matcher
            self.game_actions = game_actions
            self.progress_tracker = ProgressTracker()
            self.error_tracker = ErrorTracker()
            self.template_search_executor = None
            
        def execute_sequence(self, sequence):
            """Execute a sequence of actions."""
            if not sequence or not sequence.get("actions"):
                self.error_tracker.add_error(
                    "AutomationEngine", "SequenceError", "Empty sequence or no actions"
                )
                return False
                
            actions = sequence.get("actions", [])
            self.progress_tracker.start_sequence(len(actions))
            
            for i, action in enumerate(actions):
                action_type = action.get("type")
                if not action_type:
                    self.error_tracker.add_error(
                        "AutomationEngine", "ActionError", f"Missing action type at index {i}"
                    )
                    continue
                    
                self.progress_tracker.start_action(action_type, i)
                success = self._execute_action(action, i)
                self.progress_tracker.complete_action(i, success)
                
                if not success and not sequence.get("continue_on_error", False):
                    self.error_tracker.add_error(
                        "AutomationEngine", "SequenceError", 
                        f"Sequence aborted at action {i} due to failure"
                    )
                    self.progress_tracker.complete_sequence(False)
                    return False
            
            self.progress_tracker.complete_sequence(True)
            return True
            
        def _execute_action(self, action, index):
            """Execute a single action based on its type."""
            action_type = action.get("type")
            params = action.get("params", {})
            
            try:
                if action_type == "CLICK":
                    return self._execute_click(params)
                elif action_type == "DRAG":
                    return self._execute_drag(params)
                elif action_type == "WAIT":
                    return self._execute_wait(params)
                elif action_type == "TEMPLATE_SEARCH":
                    if not self.template_search_executor:
                        self.template_search_executor = TemplateSearchExecutor(
                            self.template_matcher, self.window_manager
                        )
                    return self.template_search_executor.execute(action)
                else:
                    self.error_tracker.add_error(
                        "AutomationEngine", "ActionError",
                        f"Unknown action type: {action_type} at index {index}"
                    )
                    return False
            except Exception as e:
                self.error_tracker.add_error(
                    "AutomationEngine", "ActionError",
                    f"Error executing {action_type} at index {index}", e
                )
                return False
                
        def _execute_click(self, params):
            """Execute a click action."""
            # Implementation
            
        def _execute_drag(self, params):
            """Execute a drag action."""
            # Implementation
            
        def _execute_wait(self, params):
            """Execute a wait action."""
            # Implementation
    ```

- [ ] **Update `automation/executor.py`**
  - [ ] Refactor to use `AutomationEngine` and `TemplateSearchExecutor`:
    ```python
    class AutomationExecutor(QObject):
        """Executes automation sequences with UI integration."""
        
        # Signals
        sequence_started = pyqtSignal(str)
        sequence_completed = pyqtSignal(str, bool)
        action_progress = pyqtSignal(int, int, str)
        
        def __init__(self, window_manager, template_matcher, game_actions):
            super().__init__()
            self.automation_engine = AutomationEngine(
                window_manager, template_matcher, game_actions
            )
            # Connect signals
            self.automation_engine.progress_tracker.progress_updated.connect(
                self._on_progress_updated
            )
            self.automation_engine.progress_tracker.sequence_completed.connect(
                self._on_sequence_completed
            )
            
        def execute_sequence(self, sequence):
            """Execute sequence from UI."""
            sequence_name = sequence.get("name", "Unnamed")
            self.sequence_started.emit(sequence_name)
            
            # Run in thread to avoid blocking UI
            self.execution_thread = QThread()
            self.worker = AutomationWorker(self.automation_engine, sequence)
            self.worker.moveToThread(self.execution_thread)
            
            # Connect signals
            self.execution_thread.started.connect(self.worker.run)
            self.worker.finished.connect(self.execution_thread.quit)
            self.worker.finished.connect(lambda success: 
                self.sequence_completed.emit(sequence_name, success)
            )
            
            # Start execution
            self.execution_thread.start()
            
        def _on_progress_updated(self, current, total, description):
            """Handle progress updates."""
            self.action_progress.emit(current, total, description)
            
        def _on_sequence_completed(self, success):
            """Handle sequence completion."""
            # Implementation
    ```

### 9. UI Component Updates

- [ ] **Update `gui.py`**
  - [ ] Add initialization checks:
    ```python
    def _validate_dependencies(self):
        """Ensure all required dependencies are available."""
        missing = []
        
        if not self.overlay:
            missing.append("Overlay")
        if not self.template_matcher:
            missing.append("TemplateMatcher")
        if not self.game_actions:
            missing.append("GameActions")
        if not self.text_ocr:
            missing.append("TextOCR")
        if not self.debug_window:
            missing.append("DebugWindow")
        
        if missing:
            error_msg = f"Missing required dependencies: {', '.join(missing)}"
            logger.error(error_msg)
            raise ValueError(error_msg)
    ```
  
  - [ ] Integrate the new screen capture tab:
    ```python
    def _initialize_tabs(self):
        """Initialize tab structure."""
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create and add tabs
        self.overlay_tab = self._create_overlay_tab()
        self.tab_widget.addTab(self.overlay_tab, "Overlay")
        
        self.automation_tab = AutomationTab(
            window_manager=self.window_manager,
            template_matcher=self.template_matcher,
            text_ocr=self.text_ocr,
            game_actions=self.game_actions
        )
        self.tab_widget.addTab(self.automation_tab, "Automation")
        
        # Add new Screen Capture tab
        from scout.screen_capture import CaptureTab
        self.capture_tab = CaptureTab()
        self.tab_widget.addTab(self.capture_tab, "Screen Capture")
        
        # Set as central widget
        self.setCentralWidget(self.tab_widget)
    ```

### 10. Update Main Application

- [ ] **Update `main.py`**
  - [ ] Integrate the new capture system:
    ```python
    def main():
        """Main application entry point."""
        # Setup logging
        configure_logging()
        
        logger.info("Starting application")
        
        try:
            app = QApplication(sys.argv)
            
            # Load configuration
            config_manager = ConfigManager()
            error_tracker = ErrorTracker()
            
            # Validate configuration
            config_errors = config_manager.validate_configuration()
            if config_errors:
                for error in config_errors:
                    logger.warning(f"Configuration error: {error}")
            
            # Load settings
            overlay_settings = config_manager.get_overlay_settings()
            template_settings = config_manager.get_template_matching_settings()
            
            # Create debug window first (for visualization)
            debug_window = DebugWindow()
            
            # Initialize window manager
            window_manager = WindowManager("Total Battle")
            
            # Initialize screen capture if available
            try:
                from scout.screen_capture import CaptureManager
                capture_manager = CaptureManager()
                # Make capture manager available to window manager
                window_manager._capture_manager = capture_manager
                logger.info("Using Qt-based screen capture system")
            except ImportError as e:
                logger.warning(f"Qt screen capture not available: {e}")
                logger.info("Using legacy screen capture system")
            
            # Create game actions controller
            game_actions = GameActions(window_manager)
            
            # Create text OCR
            text_ocr = TextOCR(
                debug_window=debug_window,
                window_manager=window_manager
            )
            
            # Create overlay with window manager and settings
            overlay = Overlay(
                window_manager=window_manager,
                template_settings=template_settings,
                overlay_settings=overlay_settings
            )
            
            # Create controller
            controller = OverlayController(
                overlay=overlay,
                overlay_settings=overlay_settings,
                template_settings=template_settings,
                game_actions=game_actions,
                text_ocr=text_ocr,
                debug_window=debug_window
            )
            
            # Set up callbacks
            controller.set_toggle_callback(overlay.toggle)
            controller.set_quit_callback(app.quit)
            
            # Show debug window if enabled in settings
            debug_settings = config_manager.get_debug_settings()
            if debug_settings.get("enabled", False):
                debug_window.show()
            
            # Show the controller window
            controller.show()
            
            # Start the application
            sys.exit(app.exec())
            
        except Exception as e:
            logger.error(f"Application error: {e}", exc_info=True)
            sys.exit(1)
    ```

## Step-by-Step Implementation

Follow this ordered checklist to implement all components:

1. [ ] Create basic supporting modules
   - [ ] `error_handling.py`
   - [ ] `utils/logging_utils.py`
   - [ ] `signals.py`
   - [ ] `window_interface.py`

2. [ ] Implement the screen capture module
   - [ ] `screen_capture/__init__.py`
   - [ ] `screen_capture/utils.py`
   - [ ] `screen_capture/screen_list_model.py`
   - [ ] `screen_capture/window_list_model.py`
   - [ ] `screen_capture/capture_manager.py`
   - [ ] `screen_capture/capture_tab.py`

3. [ ] Implement template search module
   - [ ] `template_search.py`

4. [ ] Update configuration system
   - [ ] Update `config_manager.py` 
   - [ ] Create `config/default_settings.json`

5. [ ] Refactor window management
   - [ ] Update `window_manager.py`
   - [ ] Update `window_capture.py`

6. [ ] Refactor overlay system
   - [ ] Update `overlay.py`

7. [ ] Improve automation system
   - [ ] Create `automation/core.py`
   - [ ] Create `automation/progress_tracker.py`
   - [ ] Update `automation/executor.py`
   - [ ] Update `automation/gui/*.py` files

8. [ ] Update UI components
   - [ ] Update `gui.py`
   - [ ] Update `debug_window.py`

9. [ ] Update main application
   - [ ] Update `main.py`

10. [ ] Create documentation
   - [ ] Create `docs/architecture.md`
   - [ ] Create component documentation files
   - [ ] Create workflow documentation files

This detailed implementation plan provides a clear, step-by-step approach to modernizing the TB Scout application. Following this structured process will ensure that all components are properly integrated while maintaining compatibility with the existing functionality.